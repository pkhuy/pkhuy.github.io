{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapNativeSuper\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _base64Js = _interopRequireDefault(require(\"base64-js\"));\n\nvar _eventTargetShim = _interopRequireDefault(require(\"event-target-shim\"));\n\nvar _MessageEvent = _interopRequireDefault(require(\"./MessageEvent\"));\n\nvar _RTCDataChannelEvent = _interopRequireDefault(require(\"./RTCDataChannelEvent\"));\n\nvar _EventEmitter = _interopRequireDefault(require(\"./EventEmitter\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar WebRTCModule = _reactNative.NativeModules.WebRTCModule;\nvar DATA_CHANNEL_EVENTS = ['open', 'message', 'bufferedamountlow', 'close', 'error'];\n\nvar ResourceInUse = function (_Error) {\n  (0, _inherits2.default)(ResourceInUse, _Error);\n\n  var _super = _createSuper(ResourceInUse);\n\n  function ResourceInUse() {\n    (0, _classCallCheck2.default)(this, ResourceInUse);\n    return _super.apply(this, arguments);\n  }\n\n  return ResourceInUse;\n}((0, _wrapNativeSuper2.default)(Error));\n\nvar RTCDataChannel = function (_EventTarget) {\n  (0, _inherits2.default)(RTCDataChannel, _EventTarget);\n\n  var _super2 = _createSuper(RTCDataChannel);\n\n  function RTCDataChannel(peerConnectionId, label, dataChannelDict) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, RTCDataChannel);\n    _this = _super2.call(this);\n    _this.binaryType = 'arraybuffer';\n    _this.bufferedAmount = 0;\n    _this.bufferedAmountLowThreshold = 0;\n    _this.maxPacketLifeTime = null;\n    _this.maxRetransmits = null;\n    _this.negotiated = false;\n    _this.ordered = true;\n    _this.protocol = '';\n    _this.readyState = 'connecting';\n    _this._peerConnectionId = peerConnectionId;\n    _this.label = label;\n    _this.id = 'id' in dataChannelDict ? dataChannelDict.id : -1;\n    _this.ordered = !!dataChannelDict.ordered;\n    _this.maxPacketLifeTime = dataChannelDict.maxPacketLifeTime;\n    _this.maxRetransmits = dataChannelDict.maxRetransmits;\n    _this.protocol = dataChannelDict.protocol || '';\n    _this.negotiated = !!dataChannelDict.negotiated;\n\n    _this._registerEvents();\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(RTCDataChannel, [{\n    key: \"send\",\n    value: function send(data) {\n      if (typeof data === 'string') {\n        WebRTCModule.dataChannelSend(this._peerConnectionId, this.id, data, 'text');\n        return;\n      }\n\n      if (ArrayBuffer.isView(data)) {\n        data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n      } else if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      } else {\n        throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n      }\n\n      WebRTCModule.dataChannelSend(this._peerConnectionId, this.id, _base64Js.default.fromByteArray(data), 'binary');\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.readyState === 'closing' || this.readyState === 'closed') {\n        return;\n      }\n\n      this.readyState = 'closing';\n      WebRTCModule.dataChannelClose(this._peerConnectionId, this.id);\n    }\n  }, {\n    key: \"_unregisterEvents\",\n    value: function _unregisterEvents() {\n      this._subscriptions.forEach(function (e) {\n        return e.remove();\n      });\n\n      this._subscriptions = [];\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this2 = this;\n\n      this._subscriptions = [_EventEmitter.default.addListener('dataChannelStateChanged', function (ev) {\n        if (ev.peerConnectionId !== _this2._peerConnectionId || ev.id !== _this2.id) {\n          return;\n        }\n\n        _this2.readyState = ev.state;\n\n        if (_this2.readyState === 'open') {\n          _this2.dispatchEvent(new _RTCDataChannelEvent.default('open', {\n            channel: _this2\n          }));\n        } else if (_this2.readyState === 'close') {\n          _this2.dispatchEvent(new _RTCDataChannelEvent.default('close', {\n            channel: _this2\n          }));\n\n          _this2._unregisterEvents();\n        }\n      }), _EventEmitter.default.addListener('dataChannelReceiveMessage', function (ev) {\n        if (ev.peerConnectionId !== _this2._peerConnectionId || ev.id !== _this2.id) {\n          return;\n        }\n\n        var data = ev.data;\n\n        if (ev.type === 'binary') {\n          data = _base64Js.default.toByteArray(ev.data).buffer;\n        }\n\n        _this2.dispatchEvent(new _MessageEvent.default('message', {\n          data: data\n        }));\n      })];\n    }\n  }]);\n  return RTCDataChannel;\n}((0, _eventTargetShim.default)(DATA_CHANNEL_EVENTS));\n\nexports.default = RTCDataChannel;","map":{"version":3,"sources":["F:/Expo/rnn-zoom-WebRTC/zoom/node_modules/react-native-webrtc/RTCDataChannel.js"],"names":["WebRTCModule","NativeModules","DATA_CHANNEL_EVENTS","ResourceInUse","Error","RTCDataChannel","peerConnectionId","label","dataChannelDict","binaryType","bufferedAmount","bufferedAmountLowThreshold","maxPacketLifeTime","maxRetransmits","negotiated","ordered","protocol","readyState","_peerConnectionId","id","_registerEvents","data","dataChannelSend","ArrayBuffer","isView","Uint8Array","buffer","byteOffset","byteLength","TypeError","base64","fromByteArray","dataChannelClose","_subscriptions","forEach","e","remove","EventEmitter","addListener","ev","state","dispatchEvent","RTCDataChannelEvent","channel","_unregisterEvents","type","toByteArray","MessageEvent"],"mappings":"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","sourcesContent":["'use strict';\n\nimport { NativeModules } from 'react-native';\nimport base64 from 'base64-js';\nimport EventTarget from 'event-target-shim';\nimport MessageEvent from './MessageEvent';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\nimport EventEmitter from './EventEmitter';\n\nconst {WebRTCModule} = NativeModules;\n\ntype RTCDataChannelInit = {\n  ordered?: boolean;\n  maxPacketLifeTime?: number;\n  maxRetransmits?: number;\n  protocol?: string;\n  negotiated?: boolean;\n  id?: number;\n  // deprecated:\n  maxRetransmitTime?: number,\n};\n\ntype RTCDataChannelState =\n  'connecting' |\n  'open' |\n  'closing' |\n  'closed';\n\nconst DATA_CHANNEL_EVENTS = [\n  'open',\n  'message',\n  'bufferedamountlow',\n  'close',\n  'error',\n];\n\nclass ResourceInUse extends Error {}\n\nexport default class RTCDataChannel extends EventTarget(DATA_CHANNEL_EVENTS) {\n\n  _peerConnectionId: number;\n\n  binaryType: 'arraybuffer' = 'arraybuffer'; // we only support 'arraybuffer'\n  bufferedAmount: number = 0;\n  bufferedAmountLowThreshold: number = 0;\n  id: number;\n  label: string;\n  maxPacketLifeTime: ?number = null;\n  maxRetransmits: ?number = null;\n  negotiated: boolean = false;\n  ordered: boolean = true;\n  protocol: string = '';\n  readyState: RTCDataChannelState = 'connecting';\n\n  onopen: ?Function;\n  onmessage: ?Function;\n  onbufferedamountlow: ?Function;\n  onerror: ?Function;\n  onclose: ?Function;\n\n  constructor(\n      peerConnectionId: number,\n      label: string,\n      dataChannelDict: RTCDataChannelInit) {\n    super();\n\n    this._peerConnectionId = peerConnectionId;\n\n    this.label = label;\n\n    // The standard defines dataChannelDict as optional for\n    // RTCPeerConnection#createDataChannel and that is how we have implemented\n    // the method in question. However, the method will (1) allocate an\n    // RTCDataChannel.id if the caller has not specified a value and (2)\n    // pass it to RTCDataChannel's constructor via dataChannelDict.\n    // Consequently, dataChannelDict is not optional for RTCDataChannel's\n    // constructor.\n    this.id = ('id' in dataChannelDict) ? dataChannelDict.id : -1;\n    this.ordered = !!dataChannelDict.ordered;\n    this.maxPacketLifeTime = dataChannelDict.maxPacketLifeTime;\n    this.maxRetransmits = dataChannelDict.maxRetransmits;\n    this.protocol = dataChannelDict.protocol || '';\n    this.negotiated = !!dataChannelDict.negotiated;\n\n    this._registerEvents();\n  }\n\n  send(data: string | ArrayBuffer | ArrayBufferView) {\n    if (typeof data === 'string') {\n      WebRTCModule.dataChannelSend(this._peerConnectionId, this.id, data, 'text');\n      return;\n    }\n\n    // Safely convert the buffer object to an Uint8Array for base64-encoding\n    if (ArrayBuffer.isView(data)) {\n      data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    } else if (data instanceof ArrayBuffer) {\n      data = new Uint8Array(data);\n    } else {\n      throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n    }\n    WebRTCModule.dataChannelSend(this._peerConnectionId, this.id, base64.fromByteArray(data), 'binary');\n  }\n\n  close() {\n    if (this.readyState === 'closing' || this.readyState === 'closed') {\n      return;\n    }\n    this.readyState = 'closing';\n    WebRTCModule.dataChannelClose(this._peerConnectionId, this.id);\n  }\n\n  _unregisterEvents() {\n    this._subscriptions.forEach(e => e.remove());\n    this._subscriptions = [];\n  }\n\n  _registerEvents() {\n    this._subscriptions = [\n      EventEmitter.addListener('dataChannelStateChanged', ev => {\n        if (ev.peerConnectionId !== this._peerConnectionId\n            || ev.id !== this.id) {\n          return;\n        }\n        this.readyState = ev.state;\n        if (this.readyState === 'open') {\n          this.dispatchEvent(new RTCDataChannelEvent('open', {channel: this}));\n        } else if (this.readyState === 'close') {\n          this.dispatchEvent(new RTCDataChannelEvent('close', {channel: this}));\n          this._unregisterEvents();\n        }\n      }),\n      EventEmitter.addListener('dataChannelReceiveMessage', ev => {\n        if (ev.peerConnectionId !== this._peerConnectionId\n            || ev.id !== this.id) {\n          return;\n        }\n        let data = ev.data;\n        if (ev.type === 'binary') {\n          data = base64.toByteArray(ev.data).buffer;\n        }\n        this.dispatchEvent(new MessageEvent('message', {data}));\n      }),\n    ];\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}