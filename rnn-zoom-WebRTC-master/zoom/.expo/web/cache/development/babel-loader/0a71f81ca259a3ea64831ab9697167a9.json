{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getUserMedia;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar RTCUtil = _interopRequireWildcard(require(\"./RTCUtil\"));\n\nvar _MediaStream = _interopRequireDefault(require(\"./MediaStream\"));\n\nvar _MediaStreamError = _interopRequireDefault(require(\"./MediaStreamError\"));\n\nvar _Permissions = _interopRequireDefault(require(\"./Permissions\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar WebRTCModule = _reactNative.NativeModules.WebRTCModule;\n\nfunction getUserMedia() {\n  var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (typeof constraints !== 'object') {\n    return Promise.reject(new TypeError('constraints is not a dictionary'));\n  }\n\n  if ((typeof constraints.audio === 'undefined' || !constraints.audio) && (typeof constraints.video === 'undefined' || !constraints.video)) {\n    return Promise.reject(new TypeError('audio and/or video is required'));\n  }\n\n  constraints = RTCUtil.normalizeConstraints(constraints);\n  var reqPermissions = [];\n\n  if (constraints.audio) {\n    reqPermissions.push(_Permissions.default.request({\n      name: 'microphone'\n    }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n\n  if (constraints.video) {\n    reqPermissions.push(_Permissions.default.request({\n      name: 'camera'\n    }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n\n  return new Promise(function (resolve, reject) {\n    Promise.all(reqPermissions).then(function (results) {\n      var _results = (0, _slicedToArray2.default)(results, 2),\n          audioPerm = _results[0],\n          videoPerm = _results[1];\n\n      if (!audioPerm && !videoPerm) {\n        var error = {\n          message: 'Permission denied.',\n          name: 'SecurityError'\n        };\n        reject(new _MediaStreamError.default(error));\n        return;\n      }\n\n      audioPerm || delete constraints.audio;\n      videoPerm || delete constraints.video;\n\n      var success = function success(id, tracks) {\n        for (var _iterator = _createForOfIteratorHelperLoose(tracks), _step; !(_step = _iterator()).done;) {\n          var trackInfo = _step.value;\n          var c = constraints[trackInfo.kind];\n\n          if (typeof c === 'object') {\n            trackInfo.constraints = RTCUtil.deepClone(c);\n          }\n        }\n\n        var info = {\n          streamId: id,\n          streamReactTag: id,\n          tracks: tracks\n        };\n        resolve(new _MediaStream.default(info));\n      };\n\n      var failure = function failure(type, message) {\n        var error;\n\n        switch (type) {\n          case 'TypeError':\n            error = new TypeError(message);\n            break;\n        }\n\n        if (!error) {\n          error = new _MediaStreamError.default({\n            message: message,\n            name: type\n          });\n        }\n\n        reject(error);\n      };\n\n      WebRTCModule.getUserMedia(constraints, success, failure);\n    });\n  });\n}","map":{"version":3,"sources":["F:/Expo/rnn-zoom-WebRTC/zoom/node_modules/react-native-webrtc/getUserMedia.js"],"names":["WebRTCModule","NativeModules","getUserMedia","constraints","Promise","reject","TypeError","audio","video","RTCUtil","normalizeConstraints","reqPermissions","push","permissions","request","name","resolve","all","then","results","audioPerm","videoPerm","error","message","MediaStreamError","success","id","tracks","trackInfo","c","kind","deepClone","info","streamId","streamReactTag","MediaStream","failure","type"],"mappings":"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","sourcesContent":["'use strict';\n\nimport {Platform, NativeModules} from 'react-native';\nimport * as RTCUtil from './RTCUtil';\n\nimport MediaStream from './MediaStream';\nimport MediaStreamError from './MediaStreamError';\nimport permissions from './Permissions';\n\nconst { WebRTCModule } = NativeModules;\n\n\nexport default function getUserMedia(constraints = {}) {\n  // According to\n  // https://www.w3.org/TR/mediacapture-streams/#dom-mediadevices-getusermedia,\n  // the constraints argument is a dictionary of type MediaStreamConstraints.\n  if (typeof constraints !== 'object') {\n    return Promise.reject(new TypeError('constraints is not a dictionary'));\n  }\n\n  if ((typeof constraints.audio === 'undefined' || !constraints.audio)\n      && (typeof constraints.video === 'undefined' || !constraints.video)) {\n    return Promise.reject(new TypeError('audio and/or video is required'));\n  }\n\n  // Normalize constraints.\n  constraints = RTCUtil.normalizeConstraints(constraints);\n\n  // Request required permissions\n  const reqPermissions = [];\n  if (constraints.audio) {\n    reqPermissions.push(permissions.request({ name: 'microphone' }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n  if (constraints.video) {\n    reqPermissions.push(permissions.request({ name: 'camera' }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n\n  return new Promise((resolve, reject) => {\n    Promise.all(reqPermissions).then(results => {\n      const [ audioPerm, videoPerm ] = results;\n\n      // Check permission results and remove unneeded permissions.\n\n      if (!audioPerm && !videoPerm) {\n        // https://www.w3.org/TR/mediacapture-streams/#dom-mediadevices-getusermedia\n        // step 4\n        const error = {\n          message: 'Permission denied.',\n          name: 'SecurityError'\n        };\n        reject(new MediaStreamError(error));\n\n        return;\n      }\n\n      audioPerm || (delete constraints.audio);\n      videoPerm || (delete constraints.video);\n\n      const success = (id, tracks) => {\n          // Store initial constraints.\n          for (const trackInfo of tracks) {\n            const c = constraints[trackInfo.kind];\n            if (typeof c === 'object') {\n              trackInfo.constraints = RTCUtil.deepClone(c);\n            }\n          }\n\n          const info = {\n            streamId: id,\n            streamReactTag: id,\n            tracks\n          };\n    \n          resolve(new MediaStream(info));\n      };\n\n      const failure = (type, message) => {\n          let error;\n          switch (type) {\n          case 'TypeError':\n            error = new TypeError(message);\n            break;\n          }\n          if (!error) {\n            error = new MediaStreamError({ message, name: type });\n          }\n\n          reject(error);\n      };\n\n      WebRTCModule.getUserMedia(constraints, success, failure);\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"script"}