{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _eventTargetShim = _interopRequireDefault(require(\"event-target-shim\"));\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nvar _MediaStreamTrack = _interopRequireDefault(require(\"./MediaStreamTrack\"));\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar WebRTCModule = _reactNative.NativeModules.WebRTCModule;\nvar MEDIA_STREAM_EVENTS = ['active', 'inactive', 'addtrack', 'removetrack'];\n\nvar MediaStream = function (_EventTarget) {\n  (0, _inherits2.default)(MediaStream, _EventTarget);\n\n  var _super = _createSuper(MediaStream);\n\n  function MediaStream(arg) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, MediaStream);\n    _this = _super.call(this);\n    _this.active = true;\n    _this._tracks = [];\n    _this.id = _uuid.default.v4();\n    _this._reactTag = _this.id;\n\n    if (typeof arg === 'undefined') {\n      WebRTCModule.mediaStreamCreate(_this.id);\n    } else if (arg instanceof MediaStream) {\n      WebRTCModule.mediaStreamCreate(_this.id);\n\n      for (var _iterator = _createForOfIteratorHelperLoose(arg.getTracks()), _step; !(_step = _iterator()).done;) {\n        var track = _step.value;\n\n        _this.addTrack(track);\n      }\n    } else if (Array.isArray(arg)) {\n      WebRTCModule.mediaStreamCreate(_this.id);\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(arg), _step2; !(_step2 = _iterator2()).done;) {\n        var _track = _step2.value;\n\n        _this.addTrack(_track);\n      }\n    } else if (typeof arg === 'object' && arg.streamId && arg.streamReactTag && arg.tracks) {\n      _this.id = arg.streamId;\n      _this._reactTag = arg.streamReactTag;\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(arg.tracks), _step3; !(_step3 = _iterator3()).done;) {\n        var trackInfo = _step3.value;\n\n        _this._tracks.push(new _MediaStreamTrack.default(trackInfo));\n      }\n    } else {\n      throw new TypeError(\"invalid type: \" + typeof arg);\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(MediaStream, [{\n    key: \"addTrack\",\n    value: function addTrack(track) {\n      var index = this._tracks.indexOf(track);\n\n      if (index !== -1) {\n        return;\n      }\n\n      this._tracks.push(track);\n\n      WebRTCModule.mediaStreamAddTrack(this._reactTag, track.id);\n    }\n  }, {\n    key: \"removeTrack\",\n    value: function removeTrack(track) {\n      var index = this._tracks.indexOf(track);\n\n      if (index === -1) {\n        return;\n      }\n\n      this._tracks.splice(index, 1);\n\n      WebRTCModule.mediaStreamRemoveTrack(this._reactTag, track.id);\n    }\n  }, {\n    key: \"getTracks\",\n    value: function getTracks() {\n      return this._tracks.slice();\n    }\n  }, {\n    key: \"getTrackById\",\n    value: function getTrackById(trackId) {\n      return this._tracks.find(function (track) {\n        return track.id === trackId;\n      });\n    }\n  }, {\n    key: \"getAudioTracks\",\n    value: function getAudioTracks() {\n      return this._tracks.filter(function (track) {\n        return track.kind === 'audio';\n      });\n    }\n  }, {\n    key: \"getVideoTracks\",\n    value: function getVideoTracks() {\n      return this._tracks.filter(function (track) {\n        return track.kind === 'video';\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toURL\",\n    value: function toURL() {\n      return this._reactTag;\n    }\n  }, {\n    key: \"release\",\n    value: function release() {\n      var releaseTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(this._tracks), _step4; !(_step4 = _iterator4()).done;) {\n        var track = _step4.value;\n        this.removeTrack(track);\n\n        if (releaseTracks) {\n          track.release();\n        }\n      }\n\n      WebRTCModule.mediaStreamRelease(this._reactTag);\n    }\n  }]);\n  return MediaStream;\n}((0, _eventTargetShim.default)(MEDIA_STREAM_EVENTS));\n\nexports.default = MediaStream;","map":{"version":3,"sources":["F:/Expo/rnn-zoom-WebRTC/zoom/node_modules/react-native-webrtc/MediaStream.js"],"names":["WebRTCModule","NativeModules","MEDIA_STREAM_EVENTS","MediaStream","arg","active","_tracks","id","uuid","v4","_reactTag","mediaStreamCreate","getTracks","track","addTrack","Array","isArray","streamId","streamReactTag","tracks","trackInfo","push","MediaStreamTrack","TypeError","index","indexOf","mediaStreamAddTrack","splice","mediaStreamRemoveTrack","slice","trackId","find","filter","kind","Error","releaseTracks","removeTrack","release","mediaStreamRelease"],"mappings":"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","sourcesContent":["'use strict';\n\nimport {NativeModules} from 'react-native';\nimport EventTarget from 'event-target-shim';\nimport uuid from 'uuid';\n\nimport MediaStreamTrack from './MediaStreamTrack';\n\nconst {WebRTCModule} = NativeModules;\n\nconst MEDIA_STREAM_EVENTS = [\n  'active',\n  'inactive',\n  'addtrack',\n  'removetrack',\n];\n\nexport default class MediaStream extends EventTarget(MEDIA_STREAM_EVENTS) {\n  id: string;\n  active: boolean = true;\n\n  onactive: ?Function;\n  oninactive: ?Function;\n  onaddtrack: ?Function;\n  onremovetrack: ?Function;\n\n  _tracks: Array<MediaStreamTrack> = [];\n\n  /**\n   * The identifier of this MediaStream unique within the associated\n   * WebRTCModule instance. As the id of a remote MediaStream instance is unique\n   * only within the associated RTCPeerConnection, it is not sufficiently unique\n   * to identify this MediaStream across multiple RTCPeerConnections and to\n   * unambiguously differentiate it from a local MediaStream instance not added\n   * to an RTCPeerConnection.\n   */\n  _reactTag: string;\n\n  /**\n   * A MediaStream can be constructed in several ways, depending on the paramters\n   * that are passed here.\n   *\n   * - undefined: just a new stream, with no tracks.\n   * - MediaStream instance: a new stream, with a copy of the tracks of the passed stream.\n   * - Array of MediaStreamTrack: a new stream with a copy of the tracks in the array.\n   * - object: a new stream instance, represented by the passed info object, this is always\n   *   done internally, when the stream is first created in native and the JS wrapper is\n   *   built afterwards.\n   */\n  constructor(arg) {\n      super();\n\n      // Assigm a UUID to start with. It may get overridden for remote streams.\n      this.id = uuid.v4();\n      // Local MediaStreams are created by WebRTCModule to have their id and\n      // reactTag equal because WebRTCModule follows the respective standard's\n      // recommendation for id generation i.e. uses UUID which is unique enough\n      // for the purposes of reactTag.\n      this._reactTag = this.id;\n\n      if (typeof arg === 'undefined') {\n          WebRTCModule.mediaStreamCreate(this.id);\n      } else if (arg instanceof MediaStream) {\n          WebRTCModule.mediaStreamCreate(this.id);\n          for (const track of arg.getTracks()) {\n              this.addTrack(track);\n          }\n      } else if (Array.isArray(arg)) {\n          WebRTCModule.mediaStreamCreate(this.id);\n          for (const track of arg) {\n              this.addTrack(track);\n          }\n      } else if (typeof arg === 'object' && arg.streamId && arg.streamReactTag && arg.tracks) {\n          this.id = arg.streamId;\n          this._reactTag = arg.streamReactTag;\n          for (const trackInfo of arg.tracks) {\n              // We are not using addTrack here because the track is already part of the\n              // stream, so there is no need to add it on the native side.\n              this._tracks.push(new MediaStreamTrack(trackInfo));\n          }\n      } else {\n          throw new TypeError(`invalid type: ${typeof arg}`);\n      }\n  }\n\n  addTrack(track: MediaStreamTrack) {\n      const index = this._tracks.indexOf(track);\n      if (index !== -1) {\n          return;\n      }\n      this._tracks.push(track);\n      WebRTCModule.mediaStreamAddTrack(this._reactTag, track.id);\n  }\n\n  removeTrack(track: MediaStreamTrack) {\n      const index = this._tracks.indexOf(track);\n      if (index === -1) {\n        return;\n      }\n      this._tracks.splice(index, 1);\n      WebRTCModule.mediaStreamRemoveTrack(this._reactTag, track.id);\n  }\n\n  getTracks(): Array<MediaStreamTrack> {\n    return this._tracks.slice();\n  }\n\n  getTrackById(trackId): ?MediaStreamTrack {\n    return this._tracks.find(track => track.id === trackId);\n  }\n\n  getAudioTracks(): Array<MediaStreamTrack> {\n    return this._tracks.filter(track => track.kind === 'audio');\n  }\n\n  getVideoTracks(): Array<MediaStreamTrack> {\n    return this._tracks.filter(track => track.kind === 'video');\n  }\n\n  clone() {\n    throw new Error('Not implemented.');\n  }\n\n  toURL() {\n    return this._reactTag;\n  }\n\n  release(releaseTracks = true) {\n    for (const track of this._tracks) {\n      this.removeTrack(track);\n      if (releaseTracks) {\n        track.release();\n      }\n    }\n\n    WebRTCModule.mediaStreamRelease(this._reactTag);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}