{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _eventTargetShim = _interopRequireDefault(require(\"event-target-shim\"));\n\nvar _MediaStreamErrorEvent = _interopRequireDefault(require(\"./MediaStreamErrorEvent\"));\n\nvar _RTCUtil = require(\"./RTCUtil\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar WebRTCModule = _reactNative.NativeModules.WebRTCModule;\nvar MEDIA_STREAM_TRACK_EVENTS = ['ended', 'mute', 'unmute', 'overconstrained'];\n\nvar MediaStreamTrack = function (_EventTarget) {\n  (0, _inherits2.default)(MediaStreamTrack, _EventTarget);\n\n  var _super = _createSuper(MediaStreamTrack);\n\n  function MediaStreamTrack(info) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, MediaStreamTrack);\n    _this = _super.call(this);\n    _this._constraints = info.constraints || {};\n    _this._enabled = info.enabled;\n    _this._settings = info.settings || {};\n    _this.id = info.id;\n    _this.kind = info.kind;\n    _this.label = info.label;\n    _this.muted = false;\n    _this.remote = info.remote;\n\n    var _readyState = info.readyState.toLowerCase();\n\n    _this.readyState = _readyState === \"initializing\" || _readyState === \"live\" ? \"live\" : \"ended\";\n    return _this;\n  }\n\n  (0, _createClass2.default)(MediaStreamTrack, [{\n    key: \"enabled\",\n    get: function get() {\n      return this._enabled;\n    },\n    set: function set(enabled) {\n      if (enabled === this._enabled) {\n        return;\n      }\n\n      WebRTCModule.mediaStreamTrackSetEnabled(this.id, !this._enabled);\n      this._enabled = !this._enabled;\n      this.muted = !this._enabled;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      WebRTCModule.mediaStreamTrackSetEnabled(this.id, false);\n      this.readyState = 'ended';\n    }\n  }, {\n    key: \"_switchCamera\",\n    value: function _switchCamera() {\n      if (this.remote) {\n        throw new Error('Not implemented for remote tracks');\n      }\n\n      if (this.kind !== 'video') {\n        throw new Error('Only implemented for video tracks');\n      }\n\n      WebRTCModule.mediaStreamTrackSwitchCamera(this.id);\n    }\n  }, {\n    key: \"applyConstraints\",\n    value: function applyConstraints() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"getCapabilities\",\n    value: function getCapabilities() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"getConstraints\",\n    value: function getConstraints() {\n      return (0, _RTCUtil.deepClone)(this._constraints);\n    }\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return (0, _RTCUtil.deepClone)(this._settings);\n    }\n  }, {\n    key: \"release\",\n    value: function release() {\n      WebRTCModule.mediaStreamTrackRelease(this.id);\n    }\n  }]);\n  return MediaStreamTrack;\n}((0, _eventTargetShim.default)(MEDIA_STREAM_TRACK_EVENTS));\n\nvar _default = MediaStreamTrack;\nexports.default = _default;","map":{"version":3,"sources":["F:/Expo/rnn-zoom-WebRTC/zoom/node_modules/react-native-webrtc/MediaStreamTrack.js"],"names":["WebRTCModule","NativeModules","MEDIA_STREAM_TRACK_EVENTS","MediaStreamTrack","info","_constraints","constraints","_enabled","enabled","_settings","settings","id","kind","label","muted","remote","_readyState","readyState","toLowerCase","mediaStreamTrackSetEnabled","Error","mediaStreamTrackSwitchCamera","mediaStreamTrackRelease"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;AAEA;;AACA;;AACA;;AAEA;;;;;;AAEA,IAAOA,YAAP,GAAuBC,0BAAvB,CAAOD,YAAP;AAEA,IAAME,yBAAyB,GAAG,CAChC,OADgC,EAEhC,MAFgC,EAGhC,QAHgC,EAKhC,iBALgC,CAAlC;;IAUMC,gB;;;;;AAkBJ,4BAAYC,IAAZ,EAAkB;AAAA;;AAAA;AAChB;AAEA,UAAKC,YAAL,GAAoBD,IAAI,CAACE,WAAL,IAAoB,EAAxC;AACA,UAAKC,QAAL,GAAgBH,IAAI,CAACI,OAArB;AACA,UAAKC,SAAL,GAAiBL,IAAI,CAACM,QAAL,IAAiB,EAAlC;AAEA,UAAKC,EAAL,GAAUP,IAAI,CAACO,EAAf;AACA,UAAKC,IAAL,GAAYR,IAAI,CAACQ,IAAjB;AACA,UAAKC,KAAL,GAAaT,IAAI,CAACS,KAAlB;AACA,UAAKC,KAAL,GAAa,KAAb;AACA,UAAKC,MAAL,GAAcX,IAAI,CAACW,MAAnB;;AAEA,QAAMC,WAAW,GAAGZ,IAAI,CAACa,UAAL,CAAgBC,WAAhB,EAApB;;AACA,UAAKD,UAAL,GAAmBD,WAAW,KAAK,cAAhB,IACAA,WAAW,KAAK,MADjB,GAC2B,MAD3B,GACoC,OADtD;AAdgB;AAgBjB;;;;SAED,eAAuB;AACrB,aAAO,KAAKT,QAAZ;AACD,K;SAED,aAAYC,OAAZ,EAAoC;AAClC,UAAIA,OAAO,KAAK,KAAKD,QAArB,EAA+B;AAC7B;AACD;;AACDP,MAAAA,YAAY,CAACmB,0BAAb,CAAwC,KAAKR,EAA7C,EAAiD,CAAC,KAAKJ,QAAvD;AACA,WAAKA,QAAL,GAAgB,CAAC,KAAKA,QAAtB;AACA,WAAKO,KAAL,GAAa,CAAC,KAAKP,QAAnB;AACD;;;WAED,gBAAO;AACLP,MAAAA,YAAY,CAACmB,0BAAb,CAAwC,KAAKR,EAA7C,EAAiD,KAAjD;AACA,WAAKM,UAAL,GAAkB,OAAlB;AAED;;;WASD,yBAAgB;AACd,UAAI,KAAKF,MAAT,EAAiB;AACf,cAAM,IAAIK,KAAJ,CAAU,mCAAV,CAAN;AACD;;AACD,UAAI,KAAKR,IAAL,KAAc,OAAlB,EAA2B;AACzB,cAAM,IAAIQ,KAAJ,CAAU,mCAAV,CAAN;AACD;;AACDpB,MAAAA,YAAY,CAACqB,4BAAb,CAA0C,KAAKV,EAA/C;AACD;;;WAED,4BAAmB;AACjB,YAAM,IAAIS,KAAJ,CAAU,kBAAV,CAAN;AACD;;;WAED,iBAAQ;AACN,YAAM,IAAIA,KAAJ,CAAU,kBAAV,CAAN;AACD;;;WAED,2BAAkB;AAChB,YAAM,IAAIA,KAAJ,CAAU,kBAAV,CAAN;AACD;;;WAED,0BAAiB;AACf,aAAO,wBAAU,KAAKf,YAAf,CAAP;AACD;;;WAED,uBAAc;AACZ,aAAO,wBAAU,KAAKI,SAAf,CAAP;AACD;;;WAED,mBAAU;AACRT,MAAAA,YAAY,CAACsB,uBAAb,CAAqC,KAAKX,EAA1C;AACD;;;EA9F4B,8BAAYT,yBAAZ,C;;eAiGhBC,gB","sourcesContent":["'use strict';\n\nimport {NativeModules} from 'react-native';\nimport EventTarget from 'event-target-shim';\nimport MediaStreamErrorEvent from './MediaStreamErrorEvent';\nimport type MediaStreamError from './MediaStreamError';\nimport { deepClone } from './RTCUtil';\n\nconst {WebRTCModule} = NativeModules;\n\nconst MEDIA_STREAM_TRACK_EVENTS = [\n  'ended',\n  'mute',\n  'unmute',\n  // see: https://www.w3.org/TR/mediacapture-streams/#constrainable-interface\n  'overconstrained',\n];\n\ntype MediaStreamTrackState = \"live\" | \"ended\";\n\nclass MediaStreamTrack extends EventTarget(MEDIA_STREAM_TRACK_EVENTS) {\n  _constraints: Object;\n  _enabled: boolean;\n  _settings: Object;\n\n  id: string;\n  kind: string;\n  label: string;\n  muted: boolean;\n  // readyState in java: INITIALIZING, LIVE, ENDED, FAILED\n  readyState: MediaStreamTrackState;\n  remote: boolean;\n\n  onended: ?Function;\n  onmute: ?Function;\n  onunmute: ?Function;\n  overconstrained: ?Function;\n\n  constructor(info) {\n    super();\n\n    this._constraints = info.constraints || {};\n    this._enabled = info.enabled;\n    this._settings = info.settings || {};\n\n    this.id = info.id;\n    this.kind = info.kind;\n    this.label = info.label;\n    this.muted = false;\n    this.remote = info.remote;\n\n    const _readyState = info.readyState.toLowerCase();\n    this.readyState = (_readyState === \"initializing\"\n                    || _readyState === \"live\") ? \"live\" : \"ended\";\n  }\n\n  get enabled(): boolean {\n    return this._enabled;\n  }\n\n  set enabled(enabled: boolean): void {\n    if (enabled === this._enabled) {\n      return;\n    }\n    WebRTCModule.mediaStreamTrackSetEnabled(this.id, !this._enabled);\n    this._enabled = !this._enabled;\n    this.muted = !this._enabled;\n  }\n\n  stop() {\n    WebRTCModule.mediaStreamTrackSetEnabled(this.id, false);\n    this.readyState = 'ended';\n    // TODO: save some stopped flag?\n  }\n\n  /**\n   * Private / custom API for switching the cameras on the fly, without the\n   * need for adding / removing tracks or doing any SDP renegotiation.\n   *\n   * This is how the reference application (AppRTCMobile) implements camera\n   * switching.\n   */\n  _switchCamera() {\n    if (this.remote) {\n      throw new Error('Not implemented for remote tracks');\n    }\n    if (this.kind !== 'video') {\n      throw new Error('Only implemented for video tracks');\n    }\n    WebRTCModule.mediaStreamTrackSwitchCamera(this.id);\n  }\n\n  applyConstraints() {\n    throw new Error('Not implemented.');\n  }\n\n  clone() {\n    throw new Error('Not implemented.');\n  }\n\n  getCapabilities() {\n    throw new Error('Not implemented.');\n  }\n\n  getConstraints() {\n    return deepClone(this._constraints);\n  }\n\n  getSettings() {\n    return deepClone(this._settings);\n  }\n\n  release() {\n    WebRTCModule.mediaStreamTrackRelease(this.id);\n  }\n}\n\nexport default MediaStreamTrack;\n"]},"metadata":{},"sourceType":"script"}