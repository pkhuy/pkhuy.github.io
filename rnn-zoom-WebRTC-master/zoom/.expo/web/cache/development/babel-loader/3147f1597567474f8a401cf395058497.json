{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _base64Js = _interopRequireDefault(require(\"base64-js\"));\n\nvar _eventTargetShim = _interopRequireDefault(require(\"event-target-shim\"));\n\nvar _MessageEvent = _interopRequireDefault(require(\"./MessageEvent\"));\n\nvar _RTCDataChannelEvent = _interopRequireDefault(require(\"./RTCDataChannelEvent\"));\n\nvar _EventEmitter = _interopRequireDefault(require(\"./EventEmitter\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar WebRTCModule = _reactNative.NativeModules.WebRTCModule;\nvar DATA_CHANNEL_EVENTS = ['open', 'message', 'bufferedamountlow', 'closing', 'close', 'error'];\n\nvar RTCDataChannel = function (_EventTarget) {\n  (0, _inherits2.default)(RTCDataChannel, _EventTarget);\n\n  var _super = _createSuper(RTCDataChannel);\n\n  function RTCDataChannel(info) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, RTCDataChannel);\n    _this = _super.call(this);\n    _this.binaryType = 'arraybuffer';\n    _this.bufferedAmount = 0;\n    _this.bufferedAmountLowThreshold = 0;\n    _this._peerConnectionId = info.peerConnectionId;\n    _this._reactTag = info.reactTag;\n    _this._label = info.label;\n    _this._id = info.id === -1 ? null : info.id;\n    _this._ordered = Boolean(info.ordered);\n    _this._maxPacketLifeTime = info.maxPacketLifeTime;\n    _this._maxRetransmits = info.maxRetransmits;\n    _this._protocol = info.protocol || '';\n    _this._negotiated = Boolean(info.negotiated);\n    _this._readyState = info.readyState;\n\n    _this._registerEvents();\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(RTCDataChannel, [{\n    key: \"label\",\n    get: function get() {\n      return this._label;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: \"ordered\",\n    get: function get() {\n      return this._ordered;\n    }\n  }, {\n    key: \"maxPacketLifeTime\",\n    get: function get() {\n      return this._maxPacketLifeTime;\n    }\n  }, {\n    key: \"maxRetransmits\",\n    get: function get() {\n      return this._maxRetransmits;\n    }\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._protocol;\n    }\n  }, {\n    key: \"negotiated\",\n    get: function get() {\n      return this._negotiated;\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    }\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      if (typeof data === 'string') {\n        WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, data, 'text');\n        return;\n      }\n\n      if (ArrayBuffer.isView(data)) {\n        data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n      } else if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      } else {\n        throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n      }\n\n      WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, _base64Js.default.fromByteArray(data), 'binary');\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._readyState === 'closing' || this._readyState === 'closed') {\n        return;\n      }\n\n      WebRTCModule.dataChannelClose(this._peerConnectionId, this._reactTag);\n    }\n  }, {\n    key: \"_unregisterEvents\",\n    value: function _unregisterEvents() {\n      this._subscriptions.forEach(function (e) {\n        return e.remove();\n      });\n\n      this._subscriptions = [];\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this2 = this;\n\n      this._subscriptions = [_EventEmitter.default.addListener('dataChannelStateChanged', function (ev) {\n        if (ev.reactTag !== _this2._reactTag) {\n          return;\n        }\n\n        _this2._readyState = ev.state;\n\n        if (_this2._id === null && ev.id !== -1) {\n          _this2._id = ev.id;\n        }\n\n        if (_this2._readyState === 'open') {\n          _this2.dispatchEvent(new _RTCDataChannelEvent.default('open', {\n            channel: _this2\n          }));\n        } else if (_this2._readyState === 'closing') {\n          _this2.dispatchEvent(new _RTCDataChannelEvent.default('closing', {\n            channel: _this2\n          }));\n        } else if (_this2._readyState === 'closed') {\n          _this2.dispatchEvent(new _RTCDataChannelEvent.default('close', {\n            channel: _this2\n          }));\n\n          _this2._unregisterEvents();\n\n          WebRTCModule.dataChannelDispose(_this2._peerConnectionId, _this2._reactTag);\n        }\n      }), _EventEmitter.default.addListener('dataChannelReceiveMessage', function (ev) {\n        if (ev.reactTag !== _this2._reactTag) {\n          return;\n        }\n\n        var data = ev.data;\n\n        if (ev.type === 'binary') {\n          data = _base64Js.default.toByteArray(ev.data).buffer;\n        }\n\n        _this2.dispatchEvent(new _MessageEvent.default('message', {\n          data: data\n        }));\n      })];\n    }\n  }]);\n  return RTCDataChannel;\n}((0, _eventTargetShim.default)(DATA_CHANNEL_EVENTS));\n\nexports.default = RTCDataChannel;","map":{"version":3,"sources":["F:/Expo/rnn-zoom-WebRTC/zoom/node_modules/react-native-webrtc/RTCDataChannel.js"],"names":["WebRTCModule","NativeModules","DATA_CHANNEL_EVENTS","RTCDataChannel","info","binaryType","bufferedAmount","bufferedAmountLowThreshold","_peerConnectionId","peerConnectionId","_reactTag","reactTag","_label","label","_id","id","_ordered","Boolean","ordered","_maxPacketLifeTime","maxPacketLifeTime","_maxRetransmits","maxRetransmits","_protocol","protocol","_negotiated","negotiated","_readyState","readyState","_registerEvents","data","dataChannelSend","ArrayBuffer","isView","Uint8Array","buffer","byteOffset","byteLength","TypeError","base64","fromByteArray","dataChannelClose","_subscriptions","forEach","e","remove","EventEmitter","addListener","ev","state","dispatchEvent","RTCDataChannelEvent","channel","_unregisterEvents","dataChannelDispose","type","toByteArray","MessageEvent"],"mappings":"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","sourcesContent":["'use strict';\n\nimport { NativeModules } from 'react-native';\nimport base64 from 'base64-js';\nimport EventTarget from 'event-target-shim';\nimport MessageEvent from './MessageEvent';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\nimport EventEmitter from './EventEmitter';\n\nconst {WebRTCModule} = NativeModules;\n\ntype RTCDataChannelState =\n  'connecting' |\n  'open' |\n  'closing' |\n  'closed';\n\nconst DATA_CHANNEL_EVENTS = [\n  'open',\n  'message',\n  'bufferedamountlow',\n  'closing',\n  'close',\n  'error',\n];\n\nexport default class RTCDataChannel extends EventTarget(DATA_CHANNEL_EVENTS) {\n  _peerConnectionId: number;\n  _reactTag: string;\n\n  _id: number;\n  _label: string;\n  _maxPacketLifeTime: ?number;\n  _maxRetransmits: ?number;\n  _negotiated: boolean;\n  _ordered: boolean;\n  _protocol: string;\n  _readyState: RTCDataChannelState;\n\n  binaryType: 'arraybuffer' = 'arraybuffer'; // we only support 'arraybuffer'\n  bufferedAmount: number = 0;\n  bufferedAmountLowThreshold: number = 0;\n\n  onopen: ?Function;\n  onmessage: ?Function;\n  onbufferedamountlow: ?Function;\n  onerror: ?Function;\n  onclose: ?Function;\n\n  constructor(info) {\n    super();\n\n    this._peerConnectionId = info.peerConnectionId;\n    this._reactTag = info.reactTag;\n\n    this._label = info.label;\n    this._id = info.id === -1 ? null : info.id; // null until negotiated.\n    this._ordered = Boolean(info.ordered);\n    this._maxPacketLifeTime = info.maxPacketLifeTime;\n    this._maxRetransmits = info.maxRetransmits;\n    this._protocol = info.protocol || '';\n    this._negotiated = Boolean(info.negotiated);\n    this._readyState = info.readyState;\n\n    this._registerEvents();\n  }\n\n  get label(): string {\n    return this._label;\n  }\n\n  get id(): number {\n    return this._id;\n  }\n\n  get ordered(): boolean {\n    return this._ordered;\n  }\n\n  get maxPacketLifeTime(): number {\n    return this._maxPacketLifeTime;\n  }\n\n  get maxRetransmits(): number {\n    return this._maxRetransmits;\n  }\n\n  get protocol(): string {\n    return this._protocol;\n  }\n\n  get negotiated(): boolean {\n    return this._negotiated;\n  }\n\n  get readyState(): string {\n    return this._readyState;\n  }\n\n  send(data: string | ArrayBuffer | ArrayBufferView) {\n    if (typeof data === 'string') {\n      WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, data, 'text');\n      return;\n    }\n\n    // Safely convert the buffer object to an Uint8Array for base64-encoding\n    if (ArrayBuffer.isView(data)) {\n      data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    } else if (data instanceof ArrayBuffer) {\n      data = new Uint8Array(data);\n    } else {\n      throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n    }\n    WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, base64.fromByteArray(data), 'binary');\n  }\n\n  close() {\n    if (this._readyState === 'closing' || this._readyState === 'closed') {\n      return;\n    }\n    WebRTCModule.dataChannelClose(this._peerConnectionId, this._reactTag);\n  }\n\n  _unregisterEvents() {\n    this._subscriptions.forEach(e => e.remove());\n    this._subscriptions = [];\n  }\n\n  _registerEvents() {\n    this._subscriptions = [\n      EventEmitter.addListener('dataChannelStateChanged', ev => {\n        if (ev.reactTag !== this._reactTag) {\n          return;\n        }\n        this._readyState = ev.state;\n        if (this._id === null && ev.id !== -1) {\n          this._id = ev.id;\n        }\n        if (this._readyState === 'open') {\n          this.dispatchEvent(new RTCDataChannelEvent('open', {channel: this}));\n        } else if (this._readyState === 'closing') {\n          this.dispatchEvent(new RTCDataChannelEvent('closing', {channel: this}));\n        } else if (this._readyState === 'closed') {\n          this.dispatchEvent(new RTCDataChannelEvent('close', {channel: this}));\n          this._unregisterEvents();\n          WebRTCModule.dataChannelDispose(this._peerConnectionId, this._reactTag);\n        }\n      }),\n      EventEmitter.addListener('dataChannelReceiveMessage', ev => {\n        if (ev.reactTag !== this._reactTag) {\n          return;\n        }\n        let data = ev.data;\n        if (ev.type === 'binary') {\n          data = base64.toByteArray(ev.data).buffer;\n        }\n        this.dispatchEvent(new MessageEvent('message', {data}));\n      }),\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}